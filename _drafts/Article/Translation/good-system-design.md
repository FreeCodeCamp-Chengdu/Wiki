---
title: 我所知道的关于良好系统设计的一切
date: 2025-08-17T02:16:28.405Z
authorURL: ""
originalURL: https://www.seangoedecke.com/good-system-design/
translator: ""
reviewer: ""
---


我看到很多糟糕的系统设计建议。其中一种是针对 LinkedIn 优化的"打赌你从没听说过_队列_"风格的帖子，想必是针对行业新手的。另一种是针对 Twitter 优化的"如果你在数据库中存储布尔值就是个糟糕的工程师"的巧妙技巧¹。即使是好的系统设计建议也可能有点糟糕。我喜欢《设计数据密集型应用》，但我不认为它对工程师遇到的大多数系统设计问题特别有用。

什么是系统设计？在我看来，如果软件设计是你如何组装代码行，那么系统设计就是你如何组装_服务_。软件设计的原语是变量、函数、类等等。系统设计的原语是应用服务器、数据库、缓存、队列、事件总线、代理等等。

这篇文章是我尝试用概括性的方式写下我所知道的关于良好系统设计的一切。很多具体的判断确实取决于经验，我无法在这篇文章中传达。但我正在努力写下我能写的内容。

### 识别良好的设计

良好的系统设计是什么样的？我之前写过它[看起来平淡无奇][2]。在实践中，它看起来就是长时间没有出问题。如果你有这样的想法："嗯，这比我预期的要容易"，或者"我从来不需要考虑系统的这部分，它很好"，那么你就可以知道自己处于良好设计的包围中。矛盾的是，好的设计是谦逊的：坏的设计往往比好的设计更令人印象深刻。我总是对看起来令人印象深刻的系统持怀疑态度。如果一个系统有分布式共识机制、多种不同形式的事件驱动通信、CQRS 和其他巧妙技巧，我会想是否有某种根本性的错误决定正在被弥补（或者系统只是被过度设计了）。

在这方面我常常是孤独的。工程师们看到具有许多有趣部分的复杂系统时，会想"哇，这里正在进行很多系统设计！"事实上，复杂系统通常反映了良好设计的缺失。我说"通常"是因为有时你确实需要复杂系统。我在许多理应复杂的系统上工作过。然而，一个能工作的复杂系统总是从一个能工作的简单系统演变而来。从头开始构建复杂系统是个非常糟糕的主意。

### 状态和无状态

软件设计的困难部分在于状态。如果你要存储任何信息任何时间，你都要做出很多关于如何保存、存储和提供服务的棘手决定。如果你不存储信息²³，你的应用程序就是"无状态的"。一个非平凡的例子是，GitHub 有一个内部 API，它接收 PDF 文件并返回 HTML 渲染版本。这是一个真正的无状态服务。任何写入数据库的东西都是有状态的。

你应该尽量最小化任何系统中有状态组件的数量。（在某种意义上，这是显而易见的，因为你应该尽量最小化系统中_所有_组件的数量，但有状态组件特别危险。）你应该这样做的原因是**有状态组件可能进入不良状态**。我们的无状态 PDF 渲染服务将安全地永远运行，只要你做的是大致合理的事情：例如，在可重启的容器中运行它，这样如果出现任何问题，它可以被自动杀死并恢复到工作状态。有状态服务不能像这样自动修复。如果你的数据库中有一个错误的条目（例如，一个格式会在你的应用程序中触发崩溃的条目），你必须手动进入并修复它。如果你的数据库空间不足，你必须想办法修剪不需要的数据或扩展它。

这在实践中意味着拥有一个了解状态的服务——即它与数据库对话——和其他做无状态事情的服务。避免让五个不同的服务都写入同一个表。相反，让其中四个向第一个服务发送 API 请求（或发出事件），并将写入逻辑保留在该服务中。如果可以的话，对读取逻辑也值得这样做，尽管我对此不那么绝对。服务快速读取`user_sessions`表有时比向内部会话服务发出慢 2 倍的 HTTP 请求更好。

### 数据库

由于管理状态是系统设计中最重要的部分，最重要的组件通常是状态所在的地方：数据库。我大部分时间都在使用 SQL 数据库（MySQL 和 PostgreSQL），所以这就是我要谈论的内容。

#### 模式和索引

如果你需要在数据库中存储某些内容，首先要做的是用你需要的模式定义一个表。模式设计应该是灵活的，因为一旦你有数千或数百万条记录，更改模式可能会非常痛苦。但是，如果你让它太灵活（例如，将所有内容都放在一个"value"JSON 列中，或使用"keys"和"values"表来跟踪任意数据），你会将大量复杂性加载到应用程序代码中（并且可能会带来一些非常尴尬的性能约束）。在这里画线是一个判断问题，取决于具体情况，但总的来说，我力求让我的表是人类可读的：你应该能够浏览数据库模式并大致了解应用程序存储的内容和原因。

如果你期望你的表会超过几行，你应该在其上放置索引。尝试让你的索引匹配你发送的最常见查询（例如，如果你按`email`和`type`查询，创建一个包含这两个字段的索引）。索引的工作方式类似于嵌套字典，所以确保将最高基数字段放在前面（否则每个索引查找都必须扫描所有`type`用户才能找到具有正确`email`的用户）。不要对你能想到的每一个东西都建立索引，因为每个索引都会增加写入开销。

#### 瓶颈

在高流量应用程序中，访问数据库通常是瓶颈。即使在计算方面相对低效的情况下也是如此（例如，在像 Unicorn 这样的预分叉服务器上运行的 Ruby on Rails）。这是因为复杂的应用程序需要进行_大量_数据库调用——每个请求成百上千次，通常是顺序的（因为在确认用户不是滥用者之前，你不知道是否需要检查用户是否是组织的一部分，等等）。如何避免出现瓶颈？

查询数据库时，_查询数据库_。让数据库做工作几乎总是比你亲自做更高效。例如，如果你需要来自多个表的数据，`JOIN`它们而不是进行单独查询并在内存中拼接。特别是如果你使用 ORM，要小心在内循环中意外进行查询。这是将`select id, name from table`变成`select id from table`和一百个`select name from table where id = ?`的简单方法。

偶尔你确实想要拆分查询。这种情况不常发生，但我遇到过足够丑陋的查询，以至于对数据库来说拆分它们比尝试作为单个查询运行更容易。我确信总是可以构造索引和提示，使数据库能够更好地完成工作，但偶尔的战术性查询拆分是工具箱中值得拥有的工具。

尽可能多地将读取查询发送到数据库副本。典型的数据库设置将有一个写入节点和一堆只读副本。你能避免从写入节点读取的就尽量避免——那个写入节点已经足够忙于处理所有写入了。例外情况是当你真的、真的不能容忍任何复制延迟时（因为只读副本总是至少比写入节点慢几毫秒）。但在大多数情况下，可以通过简单的技巧来解决复制延迟问题：例如，当你更新记录但需要立即使用它时，你可以在内存中填充更新后的详细信息，而不是在写入后立即重新读取。

小心查询峰值（特别是写入查询，_特别是_事务）。一旦数据库过载，它就会变慢，这会使它更加过载。事务和写入很容易使数据库过载，因为每个查询都需要大量的数据库工作。如果你正在设计一个可能产生大量查询峰值的服务（例如某种批量导入 API），考虑限制你的查询。

### 慢操作，快操作

服务必须快速做一些事情。如果用户正在与某些东西交互（比如 API 或网页），他们应该在几百毫秒内看到响应³⁴。但服务必须做一些缓慢的事情。有些操作只需要很长时间（例如，将非常大的 PDF 转换为 HTML）。这种情况的一般模式是分离出**为用户做有用事情所需的最少工作量**，并在后台完成其余工作。在 PDF 转 HTML 的例子中，你可以立即将第一页渲染为 HTML，并将其余部分排队到后台作业中。

什么是后台作业？值得详细回答这个问题，因为"后台作业"是核心的系统设计原语。每家技术公司都会有某种运行后台作业的系统。将有两个主要组件：队列集合（例如在 Redis 中），以及一个作业运行器服务，它将从队列中拾取项目并执行它们。你通过将类似`{job_name, params}`的项目放入队列来将后台作业加入队列。也可以安排后台作业在设定时间运行（这对定期清理或汇总汇总很有用）。后台作业应该是你慢操作的首选，因为它们通常是经过充分验证的路径。

有时你想要自己构建队列系统。例如，如果你想要将作业排队在一个月后运行，你可能不应该将项目放在 Redis 队列上。Redis 持久性通常不能在那段时间内得到保证（即使可以，你可能希望能够以 Redis 作业队列难以处理的方式查询那些远期排队的作业）。在这种情况下，我通常会为待处理操作创建一个数据库表，其中包含每个参数的列加上一个`scheduled_at`列。然后我使用每日作业来检查这些`scheduled_at <= today`的项目，并在作业完成后删除它们或将它们标记为完成。

### 缓存

有时操作很慢，因为它需要在用户之间执行相同的昂贵（即缓慢）任务。例如，如果你在计费服务中计算向用户收取多少费用，你可能需要进行 API 调用来查找当前价格。如果你按使用量向用户收费（像 OpenAI 按 token 收费），这可能会（a）慢得不可接受，（b）为提供价格的任何服务造成大量流量。这里的经典解决方案是**缓存**：每五分钟查找一次价格，并在此期间存储该值。在内存中缓存最容易，但使用一些快速的外部键值存储（如 Redis 或 Memcached）也很受欢迎（因为这意味着你可以在一堆应用服务器之间共享一个缓存）。

典型的模式是初级工程师了解缓存并想要缓存_所有东西_，而高级工程师想要尽可能少地缓存。为什么会这样？这归结为我关于状态危险性提出的第一个观点。缓存是状态的来源。它可能包含奇怪的数据，或与实际事实不同步，或通过提供过时数据导致神秘错误等等。你永远不应该在没有首先认真努力加快速度的情况下缓存某些东西。例如，缓存一个没有数据库索引覆盖的昂贵 SQL 查询是很愚蠢的。你应该只添加数据库索引！

我经常使用缓存。工具箱中一个有用的缓存技巧是使用计划作业和文档存储（如 S3 或 Azure Blob Storage）作为大规模持久缓存。如果你需要缓存_真正_昂贵操作的结果（比如大客户的每周使用报告），你可能无法将结果放入 Redis 或 Memcached。相反，将带时间戳的结果块粘贴到你的文档存储中并直接从那里提供文件。就像我上面提到的数据库支持的长期队列一样，这是使用缓存_概念_而不使用特定缓存技术的例子。

### 事件

除了某种缓存基础设施和后台作业系统外，技术公司通常还会有_事件中心_。最常见的实现是 Kafka。事件中心只是一个队列——就像后台作业的队列一样——但不是在队列上放置"用这些参数运行这个作业"，而是在队列上放置"这件事发生了"。一个经典的例子是为每个新帐户触发"新帐户创建"事件，然后让多个服务消费该事件并采取一些行动："发送欢迎邮件"服务、"扫描滥用"服务、"设置每个帐户基础设施"服务等等。

你不应该过度使用事件。大多数时候，最好让一个服务向另一个服务发出 API 请求：所有日志都在同一个地方，更容易推理，你可以立即看到其他服务响应了什么。事件适用于发送事件的代码不一定关心消费者对事件做什么的情况，或者当事件是高容量且不是特别时间敏感的时候（例如，对每个新的 Twitter 帖子进行滥用扫描）。

### 推送和拉取

当你需要数据从一个地方流向许多其他地方时，有两个选择。最简单的是_拉取_。这是大多数网站的工作方式：你有一个拥有某些数据的服务器，当用户想要它时，他们向服务器发出请求（通过浏览器）将数据拉取到他们那里。这里的问题是用户可能会进行大量拉取相同数据的操作——例如，刷新他们的电子邮件收件箱以查看是否有新邮件，这将拉取并重新加载整个 Web 应用程序，而不仅仅是关于邮件的数据。

另一种选择是_推送_。不是让用户请求数据，而是允许他们注册为客户端，然后当数据更改时，服务器将数据推送到每个客户端。这就是 GMail 的工作方式：你不必刷新页面来获取新邮件，因为它们到达时就会显示出来。

如果我们谈论的是后台服务而不是使用 Web 浏览器的用户，很容易看出为什么推送可能是个好主意。即使在非常大的系统中，你可能也只有大约一百个服务需要相同的数据。对于不经常更改的数据，每当数据更改时进行一百次 HTTP 请求（或 RPC 或其他请求）比每秒提供相同数据一千次要容易得多。

假设你确实需要向一百万个客户端提供最新数据（像 GMail 那样）。这些客户端应该是推送还是拉取？这取决于具体情况。无论哪种方式，你都无法从单个服务器运行所有内容，因此你需要将其分配给系统的其他组件。如果你在推送，这可能意味着将每个推送到事件队列上，并有一群事件处理器从队列中拉取并发送你的推送。如果你在拉取，这意味着建立一堆（比如一百个）快速⁴⁵只读副本缓存服务器，它们将位于你的主应用程序前面并处理所有读取流量⁵⁶。

### 热路径

当你设计系统时，有很多不同的方式用户可以与之交互或数据可以流经它。这可能会让人有点不知所措。诀窍是主要关注"热路径"：系统中最重要的部分，以及将要处理最多数据的系统部分。例如，在计量计费系统中，这些部分可能是决定客户是否被收费的部分，以及需要挂钩到平台上所有用户操作以识别收费金额的部分。

热路径很重要，因为它们比其他设计区域有更少的可能解决方案。有一千种方法可以构建计费设置页面，它们都会主要工作。但可能只有少数几种方法可以合理地消费用户操作的消防水管。热路径也会更壮观地出错。你必须真的搞砸一个设置页面才能使整个产品崩溃，但你在所有用户操作上触发的任何代码都可能轻易造成巨大问题。

### 日志记录和指标

你怎么知道是否有问题？我从我最偏执的同事那里学到的一件事是在不愉快的路径中积极记录日志。如果你正在编写一个函数来检查一堆条件以查看面向用户的端点是否应该响应 422，你应该记录被触发的条件。如果你正在编写计费代码，你应该记录每个做出的决定（例如，"我们不为此事件收费，因为 X"）。许多工程师不这样做，因为它增加了一堆日志模板代码，使编写优美的代码变得困难，但无论如何你应该这样做。当重要客户抱怨他们收到 422 时，你会高兴你这样做了——即使那个客户做错了什么，你仍然需要找出_他们做错了什么_。

你还应该对系统的操作部分有基本的可观察性。这意味着主机或容器上的 CPU/内存、队列大小、每个请求或每个作业的平均时间等等。对于像每个请求时间这样的面向用户的指标，你还需要观察 p95 和 p99（即你最慢的请求有多慢）。即使一两个非常慢的请求也很可怕，因为它们不成比例地来自你最大和最重要的用户。如果你只看平均值，很容易错过一些用户发现你的服务不可用的事实。

### 终止开关、重试和优雅失败

我写过一篇关于终止开关的[整篇文章][7]，我在这里不会重复，但要点是当系统严重失败时，你应该仔细考虑会发生什么。

重试不是万能药。你需要确保不要通过盲目重试失败的请求来给其他服务增加额外负载。如果可以，将高容量 API 调用放在"断路器"内：如果你连续收到太多 5xx 响应，停止发送请求一段时间以让服务恢复。你还需要确保不要重试可能成功也可能失败的写入事件（例如，如果你发送"向此用户收费"请求并返回 5xx，_你不知道_用户是否已被收费）。对此的经典解决方案是使用"幂等键"，这是请求中的特殊 UUID，其他服务使用它来避免重新运行旧请求：每次他们做某事时，他们保存幂等键，如果他们收到另一个具有相同键的请求，他们会默默地忽略它。

决定系统部分失败时发生什么也很重要。例如，假设你有一些速率限制代码，检查 Redis 桶以查看用户在当前窗口内是否发出了太多请求。当 Redis 桶不可用时会发生什么？你有两个选择：fail _open_并让请求通过，或 fail _closed_并用 429 阻止请求。

你应该 fail open 还是 fail closed 取决于具体功能。在我看来，速率限制系统几乎应该总是 fail open。这意味着速率限制代码的问题不一定是大的面向用户的事件。但是，身份验证应该（显然）总是 fail closed：拒绝用户访问自己的数据比让用户访问其他用户的数据更好。在很多情况下，不清楚正确的行为是什么。这通常是一个困难的权衡。

### 最后的想法

我在这里故意不讨论一些主题。例如，是否或何时将你的单体拆分成不同的服务，何时使用容器或虚拟机，追踪，良好的 API 设计。部分原因是因为我认为这并不那么重要（根据我的经验，单体很好），或者我认为谈论它太明显了（你应该使用追踪），或者只是因为我没有时间（API 设计很复杂）。

我试图表达的主要观点是我在本文开头所说的：良好的系统设计不是关于巧妙的技巧，而是关于知道如何在正确的位置使用无聊的、经过良好测试的组件。我不是水管工，但我想象良好的管道工作类似：如果你做的事情太令人兴奋，你可能会最终把自己弄得一团糟。

特别是在大型技术公司，这些组件已经现成存在（即你的公司已经有某种事件总线、缓存服务等），良好的系统设计看起来就像什么都没做。很少有、非常少的领域你想要做那种可以在会议上谈论的系统设计。它们确实存在！我看到过手写数据结构使否则不可能的功能成为可能。但我在十年中只看到这种情况发生一两次。我每天看到的都是无聊的系统设计。

---

---

**注解：**

¹ 你应该存储时间戳，并将时间戳的存在视为`true`。我有时这样做但不总是——在我看来，保持数据库模式立即可读有一些价值。

² 从技术上讲，任何服务都会在某种程度上存储某种信息一段时间，至少在内存中。这里通常的意思是在请求-响应生命周期之外存储信息（例如，在某处持久化在磁盘上，如在数据库中）。如果你可以通过简单地启动应用服务器来推出应用程序的新版本，那就是一个无状态应用程序。

³ Twitter 上的游戏开发者会说任何慢于 10ms 的东西都是不可接受的。无论情况是否应该如此，对于成功的技术产品来说事实并非如此——如果应用程序正在做对他们有用的事情，用户会接受较慢的响应。

⁴ 它们很快，因为它们不必像主服务器那样与数据库对话。理论上，这可能只是它们在被询问时提供的磁盘上的静态文件，甚至是内存中保存的数据。

⁵ 顺便说一句，那些缓存服务器要么轮询你的主服务器（即拉取），要么你的主服务器将新数据发送给它们（即推送）。我认为你采用哪种方式并不太重要。推送会给你更新的数据，但拉取更简单。

⁶ 另一个脚注说明。

如果你喜欢这篇文章，考虑[订阅][13]我的新文章的电子邮件更新，或在[Hacker News 上分享][14]。

2025 年 6 月 21 日 │ 标签：[good engineers][15], [software design][16]

---

[订阅][17] │ [联系我][18] │ [rss 订阅][19] │ [书籍][20] │ [我目前的工作][21]

[2]: https://www.seangoedecke.com/great-software-design/
[7]: https://www.seangoedecke.com/killswitches/
[13]: https://buttondown.com/seangoedecke
[14]: https://news.ycombinator.com/submitlink?u=https://www.seangoedecke.com/good-system-design/
[15]: https://www.seangoedecke.com/tags/good%20engineers/
[16]: https://www.seangoedecke.com/tags/software%20design/
[17]: https://buttondown.com/seangoedecke
[18]: https://www.seangoedecke.com/about/
[19]: https://www.seangoedecke.com/rss.xml
[20]: https://www.seangoedecke.com/book/
[21]: https://github.blog/ai-and-ml/llms/solving-the-inference-problem-for-open-source-ai-projects-with-github-models/
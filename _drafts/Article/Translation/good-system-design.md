---
title: 我所知道的关于良好系统设计的一切
date: 2025-08-17T02:16:28.405Z
authorURL: ""
originalURL: https://www.seangoedecke.com/good-system-design/
translator: ""
reviewer: ""
---


我见过很多糟糕的系统设计建议。比如在 LinkedIn 上常见的那种"打赌你从没听说过_队列_"的帖子，明显是针对行业新手的。还有 Twitter 上那种"在数据库中存储布尔值的工程师都是糟糕的"的所谓技巧¹。即使是好的系统设计建议，有时也可能不太实用。我很欣赏《设计数据密集型应用》这本书，但我觉得它对大多数工程师日常遇到的系统设计问题帮助有限。

什么是系统设计？简单来说，如果说软件设计是关于如何组织代码，那么系统设计就是关于如何组织服务。软件设计的基本元素是变量、函数、类等；而系统设计的基本元素是应用服务器、数据库、缓存、队列、事件总线、代理等。

这篇文章我尝试用比较概括的方式，分享我所知道的关于良好系统设计的要点。很多具体的判断确实要靠经验积累，很难在这篇文章里完全说清楚。但我会尽力写下我认为最重要的内容。

### 识别良好的设计

什么样的系统设计才算好？我之前写过一篇关于这个话题的文章，提到好的设计[看起来往往很平淡][2]。在实际工作中，好的系统设计表现为长时间稳定运行不出问题。当你发现"咦，这个实现比预想的简单多了"，或者"这部分系统我几乎不用操心，运行得很稳定"时，说明你可能遇到了好的设计。

有趣的是，好的设计往往是低调的，而糟糕的设计反而常常更引人注目。我总是对那些看起来很"炫酷"的系统保持警惕。如果一个系统到处都是分布式共识机制、各种事件驱动通信、CQRS 模式和其他巧妙技巧，我就会怀疑：是不是有什么根本性的设计错误需要用这些复杂技术来弥补？或者这个系统本身就是过度设计了。

在这点上，我的看法往往与主流不同。很多工程师看到那些充满复杂组件的系统时会感叹："哇，这里面的系统设计真厉害！"但实际上，复杂的系统往往恰恰说明设计不够好。当然，我说的只是通常情况——有些场景确实需要复杂的系统。我也参与过一些确实需要复杂性的项目。但关键在于：任何能正常运行的复杂系统，都是从能正常运行的简单系统逐步演化而来的。如果一开始就追求复杂，那注定会失败。

### 状态和无状态

软件设计中最大的挑战在于状态管理。只要你需要持久化存储任何信息，就会面临很多棘手的问题：如何保存、如何存储、如何提供服务。如果你的应用不需要持久化存储信息²³，那就是"无状态"的。举个例子，GitHub 有个内部 API，专门接收 PDF 文件并返回 HTML 渲染结果，这就是典型的无状态服务。而任何需要写入数据库的应用，都是有状态的。

在任何系统中，都应该尽量减少有状态组件的数量。这不仅是因为要减少组件总数，更重要的是有状态组件会带来额外的风险。

为什么有状态组件特别麻烦？因为**有状态组件可能会进入错误状态**。比如我们的无状态 PDF 渲染服务，只要配置合理，就能一直安全运行。即使出问题，也可以通过容器重启来自动恢复。但有状态服务就没这么简单了。如果数据库里有一条格式错误的数据导致应用崩溃，你必须手动修复；如果数据库空间满了，你必须清理数据或扩容。

基于这个原则，最佳实践是：让一个专门的服务负责状态管理（即与数据库交互），其他服务保持无状态。要避免五个不同的服务都往同一个表里写数据。更好的做法是让其中四个服务通过 API 调用或事件消息，让那个专门的服务来处理写入操作。

读取逻辑也可以考虑集中处理，虽然我不那么坚持这点。有时候，让服务直接读取 `user_sessions` 表，比调用一个慢 2 倍的内部会话服务 API 更实际。

### 数据库

既然状态管理是系统设计的核心，那么存储状态的组件——也就是数据库——自然就成了系统中最关键的部分。我大部分工作经验都来自 SQL 数据库（主要是 MySQL 和 PostgreSQL），所以接下来的内容主要围绕这个主题。

#### 模式和索引

要在数据库中存储数据，首先要设计表结构。模式设计需要保持一定的灵活性，因为当数据量达到几十万甚至几百万条时，修改表结构会非常痛苦。

但也不能过度灵活。比如把所有数据都塞进一个 JSON 字段，或者用"键值表"来存储任意数据，这样会把大量复杂性推到应用代码里，还可能带来性能问题。

如何在灵活性和简单性之间找到平衡点，这要视具体情况而定。但我的原则是：表结构应该让人容易理解。通过查看数据库模式，就能大致了解应用在存储什么数据以及为什么这样存储。

如果预计表中会有较多数据，就应该创建索引。索引设计要匹配最常见的查询模式——比如经常按 `email` 和 `type` 字段查询，就应该创建包含这两个字段的索引。

索引的原理类似于多层字典，所以要把基数高的字段放在前面。否则，如果要查找特定 `email` 的用户，数据库可能需要扫描所有相同 `type` 的用户才能找到目标。

但也不是什么字段都要建索引，因为每个索引都会增加写入的开销。

#### 瓶颈

在高流量应用中，数据库访问往往是最大的瓶颈。即使应用的计算层效率不高（比如在 Unicorn 服务器上运行的 Ruby on Rails），数据库仍然更容易成为瓶颈。

为什么会这样？因为复杂应用需要做大量的数据库操作——单个请求可能触发成百上千次数据库调用，而且这些调用常常是串行的。比如，要先确认用户不是恶意用户，才能检查用户是否属于某个组织，然后才能进行后续操作，这样一步步下来，数据库调用就累积起来了。

如何避免数据库成为瓶颈？

查询数据库时，要**充分利用数据库的能力**。让数据库完成工作通常比在应用代码中处理更高效。比如需要多表数据时，应该用 `JOIN` 而不是分别查询再在内存中合并。

使用 ORM 时要特别小心，很容易在循环中触发查询而不自知。这会把一个简单的 `select id, name from table` 变成一个 `select id from table` 查询加上一百个 `select name from table where id = ?` 查询。

当然，有时候确实需要拆分查询。这种情况不常见，但我遇到过一些极其复杂的查询，对数据库来说，拆分成多个简单查询比执行单个复杂查询更高效。我相信通过优化索引和查询提示，总能找到让数据库更好地执行单个查询的方法，但适度的查询拆分也是一个有用的技巧。

尽量把读取请求发送到数据库的只读副本。典型的数据库部署会有一个主节点（负责写入）和多个只读副本。要尽可能避免从主节点读取数据，因为它已经够忙的了。

例外情况是当你完全无法接受任何复制延迟时（因为只读副本通常比主节点晚几毫秒）。但在大多数场景下，可以通过一些小技巧来解决延迟问题。比如，更新记录后需要立即使用，可以在内存中保存更新后的数据，而不是马上重新查询数据库。

要警惕查询峰值，尤其是写入查询和事务。一旦数据库过载，响应就会变慢，而这又会引发更多请求，形成恶性循环。事务和写入操作特别容易导致数据库过载，因为它们需要大量的数据库资源。

如果你在设计可能产生大量查询峰值的服务（比如批量导入 API），应该考虑添加查询限制机制。

### 慢操作，快操作

服务必须快速做一些事情。如果用户正在与某些东西交互（比如 API 或网页），他们应该在几百毫秒内看到响应³⁴。但服务必须做一些缓慢的事情。有些操作只需要很长时间（例如，将非常大的 PDF 转换为 HTML）。这种情况的一般模式是分离出**为用户做有用事情所需的最少工作量**，并在后台完成其余工作。在 PDF 转 HTML 的例子中，你可以立即将第一页渲染为 HTML，并将其余部分排队到后台作业中。

什么是后台作业？值得详细回答这个问题，因为"后台作业"是核心的系统设计原语。每家技术公司都会有某种运行后台作业的系统。将有两个主要组件：队列集合（例如在 Redis 中），以及一个作业运行器服务，它将从队列中拾取项目并执行它们。你通过将类似`{job_name, params}`的项目放入队列来将后台作业加入队列。也可以安排后台作业在设定时间运行（这对定期清理或汇总汇总很有用）。后台作业应该是你慢操作的首选，因为它们通常是经过充分验证的路径。

有时你想要自己构建队列系统。例如，如果你想要将作业排队在一个月后运行，你可能不应该将项目放在 Redis 队列上。Redis 持久性通常不能在那段时间内得到保证（即使可以，你可能希望能够以 Redis 作业队列难以处理的方式查询那些远期排队的作业）。在这种情况下，我通常会为待处理操作创建一个数据库表，其中包含每个参数的列加上一个`scheduled_at`列。然后我使用每日作业来检查这些`scheduled_at <= today`的项目，并在作业完成后删除它们或将它们标记为完成。

### 缓存

有时操作很慢，因为它需要在用户之间执行相同的昂贵（即缓慢）任务。例如，如果你在计费服务中计算向用户收取多少费用，你可能需要进行 API 调用来查找当前价格。如果你按使用量向用户收费（像 OpenAI 按 token 收费），这可能会（a）慢得不可接受，（b）为提供价格的任何服务造成大量流量。这里的经典解决方案是**缓存**：每五分钟查找一次价格，并在此期间存储该值。在内存中缓存最容易，但使用一些快速的外部键值存储（如 Redis 或 Memcached）也很受欢迎（因为这意味着你可以在一堆应用服务器之间共享一个缓存）。

典型的模式是初级工程师了解缓存并想要缓存_所有东西_，而高级工程师想要尽可能少地缓存。为什么会这样？这归结为我关于状态危险性提出的第一个观点。缓存是状态的来源。它可能包含奇怪的数据，或与实际事实不同步，或通过提供过时数据导致神秘错误等等。你永远不应该在没有首先认真努力加快速度的情况下缓存某些东西。例如，缓存一个没有数据库索引覆盖的昂贵 SQL 查询是很愚蠢的。你应该只添加数据库索引！

我经常使用缓存。工具箱中一个有用的缓存技巧是使用计划作业和文档存储（如 S3 或 Azure Blob Storage）作为大规模持久缓存。如果你需要缓存_真正_昂贵操作的结果（比如大客户的每周使用报告），你可能无法将结果放入 Redis 或 Memcached。相反，将带时间戳的结果块粘贴到你的文档存储中并直接从那里提供文件。就像我上面提到的数据库支持的长期队列一样，这是使用缓存_概念_而不使用特定缓存技术的例子。

### 事件

除了某种缓存基础设施和后台作业系统外，技术公司通常还会有_事件中心_。最常见的实现是 Kafka。事件中心只是一个队列——就像后台作业的队列一样——但不是在队列上放置"用这些参数运行这个作业"，而是在队列上放置"这件事发生了"。一个经典的例子是为每个新帐户触发"新帐户创建"事件，然后让多个服务消费该事件并采取一些行动："发送欢迎邮件"服务、"扫描滥用"服务、"设置每个帐户基础设施"服务等等。

你不应该过度使用事件。大多数时候，最好让一个服务向另一个服务发出 API 请求：所有日志都在同一个地方，更容易推理，你可以立即看到其他服务响应了什么。事件适用于发送事件的代码不一定关心消费者对事件做什么的情况，或者当事件是高容量且不是特别时间敏感的时候（例如，对每个新的 Twitter 帖子进行滥用扫描）。

### 推送和拉取

当你需要数据从一个地方流向许多其他地方时，有两个选择。最简单的是_拉取_。这是大多数网站的工作方式：你有一个拥有某些数据的服务器，当用户想要它时，他们向服务器发出请求（通过浏览器）将数据拉取到他们那里。这里的问题是用户可能会进行大量拉取相同数据的操作——例如，刷新他们的电子邮件收件箱以查看是否有新邮件，这将拉取并重新加载整个 Web 应用程序，而不仅仅是关于邮件的数据。

另一种选择是_推送_。不是让用户请求数据，而是允许他们注册为客户端，然后当数据更改时，服务器将数据推送到每个客户端。这就是 GMail 的工作方式：你不必刷新页面来获取新邮件，因为它们到达时就会显示出来。

如果我们谈论的是后台服务而不是使用 Web 浏览器的用户，很容易看出为什么推送可能是个好主意。即使在非常大的系统中，你可能也只有大约一百个服务需要相同的数据。对于不经常更改的数据，每当数据更改时进行一百次 HTTP 请求（或 RPC 或其他请求）比每秒提供相同数据一千次要容易得多。

假设你确实需要向一百万个客户端提供最新数据（像 GMail 那样）。这些客户端应该是推送还是拉取？这取决于具体情况。无论哪种方式，你都无法从单个服务器运行所有内容，因此你需要将其分配给系统的其他组件。如果你在推送，这可能意味着将每个推送到事件队列上，并有一群事件处理器从队列中拉取并发送你的推送。如果你在拉取，这意味着建立一堆（比如一百个）快速⁴⁵只读副本缓存服务器，它们将位于你的主应用程序前面并处理所有读取流量⁵⁶。

### 热路径

当你设计系统时，有很多不同的方式用户可以与之交互或数据可以流经它。这可能会让人有点不知所措。诀窍是主要关注"热路径"：系统中最重要的部分，以及将要处理最多数据的系统部分。例如，在计量计费系统中，这些部分可能是决定客户是否被收费的部分，以及需要挂钩到平台上所有用户操作以识别收费金额的部分。

热路径很重要，因为它们比其他设计区域有更少的可能解决方案。有一千种方法可以构建计费设置页面，它们都会主要工作。但可能只有少数几种方法可以合理地消费用户操作的消防水管。热路径也会更壮观地出错。你必须真的搞砸一个设置页面才能使整个产品崩溃，但你在所有用户操作上触发的任何代码都可能轻易造成巨大问题。

### 日志记录和指标

你怎么知道是否有问题？我从我最偏执的同事那里学到的一件事是在不愉快的路径中积极记录日志。如果你正在编写一个函数来检查一堆条件以查看面向用户的端点是否应该响应 422，你应该记录被触发的条件。如果你正在编写计费代码，你应该记录每个做出的决定（例如，"我们不为此事件收费，因为 X"）。许多工程师不这样做，因为它增加了一堆日志模板代码，使编写优美的代码变得困难，但无论如何你应该这样做。当重要客户抱怨他们收到 422 时，你会高兴你这样做了——即使那个客户做错了什么，你仍然需要找出_他们做错了什么_。

你还应该对系统的操作部分有基本的可观察性。这意味着主机或容器上的 CPU/内存、队列大小、每个请求或每个作业的平均时间等等。对于像每个请求时间这样的面向用户的指标，你还需要观察 p95 和 p99（即你最慢的请求有多慢）。即使一两个非常慢的请求也很可怕，因为它们不成比例地来自你最大和最重要的用户。如果你只看平均值，很容易错过一些用户发现你的服务不可用的事实。

### 终止开关、重试和优雅失败

我写过一篇关于终止开关的[整篇文章][7]，我在这里不会重复，但要点是当系统严重失败时，你应该仔细考虑会发生什么。

重试不是万能药。你需要确保不要通过盲目重试失败的请求来给其他服务增加额外负载。如果可以，将高容量 API 调用放在"断路器"内：如果你连续收到太多 5xx 响应，停止发送请求一段时间以让服务恢复。你还需要确保不要重试可能成功也可能失败的写入事件（例如，如果你发送"向此用户收费"请求并返回 5xx，_你不知道_用户是否已被收费）。对此的经典解决方案是使用"幂等键"，这是请求中的特殊 UUID，其他服务使用它来避免重新运行旧请求：每次他们做某事时，他们保存幂等键，如果他们收到另一个具有相同键的请求，他们会默默地忽略它。

决定系统部分失败时发生什么也很重要。例如，假设你有一些速率限制代码，检查 Redis 桶以查看用户在当前窗口内是否发出了太多请求。当 Redis 桶不可用时会发生什么？你有两个选择：fail _open_并让请求通过，或 fail _closed_并用 429 阻止请求。

你应该 fail open 还是 fail closed 取决于具体功能。在我看来，速率限制系统几乎应该总是 fail open。这意味着速率限制代码的问题不一定是大的面向用户的事件。但是，身份验证应该（显然）总是 fail closed：拒绝用户访问自己的数据比让用户访问其他用户的数据更好。在很多情况下，不清楚正确的行为是什么。这通常是一个困难的权衡。

### 最后的想法

我在这里故意不讨论一些主题。例如，是否或何时将你的单体拆分成不同的服务，何时使用容器或虚拟机，追踪，良好的 API 设计。部分原因是因为我认为这并不那么重要（根据我的经验，单体很好），或者我认为谈论它太明显了（你应该使用追踪），或者只是因为我没有时间（API 设计很复杂）。

我试图表达的主要观点是我在本文开头所说的：良好的系统设计不是关于巧妙的技巧，而是关于知道如何在正确的位置使用无聊的、经过良好测试的组件。我不是水管工，但我想象良好的管道工作类似：如果你做的事情太令人兴奋，你可能会最终把自己弄得一团糟。

特别是在大型技术公司，这些组件已经现成存在（即你的公司已经有某种事件总线、缓存服务等），良好的系统设计看起来就像什么都没做。很少有、非常少的领域你想要做那种可以在会议上谈论的系统设计。它们确实存在！我看到过手写数据结构使否则不可能的功能成为可能。但我在十年中只看到这种情况发生一两次。我每天看到的都是无聊的系统设计。

---

---

**注解：**

¹ 你应该存储时间戳，并将时间戳的存在视为`true`。我有时这样做但不总是——在我看来，保持数据库模式立即可读有一些价值。

² 从技术上讲，任何服务都会在某种程度上存储某种信息一段时间，至少在内存中。这里通常的意思是在请求-响应生命周期之外存储信息（例如，在某处持久化在磁盘上，如在数据库中）。如果你可以通过简单地启动应用服务器来推出应用程序的新版本，那就是一个无状态应用程序。

³ Twitter 上的游戏开发者会说任何慢于 10ms 的东西都是不可接受的。无论情况是否应该如此，对于成功的技术产品来说事实并非如此——如果应用程序正在做对他们有用的事情，用户会接受较慢的响应。

⁴ 它们很快，因为它们不必像主服务器那样与数据库对话。理论上，这可能只是它们在被询问时提供的磁盘上的静态文件，甚至是内存中保存的数据。

⁵ 顺便说一句，那些缓存服务器要么轮询你的主服务器（即拉取），要么你的主服务器将新数据发送给它们（即推送）。我认为你采用哪种方式并不太重要。推送会给你更新的数据，但拉取更简单。

⁶ 另一个脚注说明。

如果你喜欢这篇文章，考虑[订阅][13]我的新文章的电子邮件更新，或在[Hacker News 上分享][14]。

2025 年 6 月 21 日 │ 标签：[good engineers][15], [software design][16]

---

[订阅][17] │ [联系我][18] │ [rss 订阅][19] │ [书籍][20] │ [我目前的工作][21]

[2]: https://www.seangoedecke.com/great-software-design/
[7]: https://www.seangoedecke.com/killswitches/
[13]: https://buttondown.com/seangoedecke
[14]: https://news.ycombinator.com/submitlink?u=https://www.seangoedecke.com/good-system-design/
[15]: https://www.seangoedecke.com/tags/good%20engineers/
[16]: https://www.seangoedecke.com/tags/software%20design/
[17]: https://buttondown.com/seangoedecke
[18]: https://www.seangoedecke.com/about/
[19]: https://www.seangoedecke.com/rss.xml
[20]: https://www.seangoedecke.com/book/
[21]: https://github.blog/ai-and-ml/llms/solving-the-inference-problem-for-open-source-ai-projects-with-github-models/
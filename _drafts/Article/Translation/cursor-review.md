---
title: "我如何使用 Cursor 编写代码:一篇评测"
date: 2024-11-05T08:50:21.566Z
authorURL: ""
originalURL: https://www.arguingwithalgorithms.com/posts/cursor-review.html
translator: ""
reviewer: ""
---

在 AI 和 AI 编程相关的论坛中,我经常看到有经验的软件开发者提出这样的问题:_有人真的从 Cursor 这类工具中获得价值吗?它值得订阅吗?_

<!-- more -->

在将 Cursor 作为我个人和工作项目的日常开发工具使用了几个月后,我想分享一些观察心得,包括这是否是一个"必备"工具还是昙花一现的潮流,以及如何快速获得最大收益的策略,这些建议可能对想要试用它的人有帮助。有些人可能已经尝试过 Cursor 并觉得平平无奇,也许这些建议能激发你重新尝试一下。

我没有受到 Cursor 的赞助,我也不是产品评测人员。我既不是在为这个产品摇旗呐喊,也不是在贬低它,而是分享我自己使用它的经历。

**我是谁,这篇文章的目标读者是谁?**

我已经有 36 年的编程经验,使用过多种编程语言,但专业上主要专注于以 C 语言为主的电脑游戏引擎和 Go/Python/JS 网页开发。我期望读者也同样能够在大型代码库中得心应手,能够用自己选择的语言编写和调试代码等。对于想要通过 AI 学习编程概念或者让 AI 编写远超出他们水平的代码的新手,我会给出非常不同的建议!

对我来说,AI 辅助编程的吸引力在于它能帮我处理样板代码和重复性任务,这样我就可以专注于任何给定问题的有趣逻辑部分。我也对自动生成大量代码不太感兴趣;我对"编写的代码行数"作为效率指标持高度怀疑态度。我更愿意花更少的时间写同样数量的代码,把更多时间用于思考边界情况、可维护性等方面。

那么,让我们开始吧:

## Cursor 是什么?

[Cursor][1] 是 Visual Studio Code (VS Code) 的一个分支,它在核心 UI 中集成了大语言模型(LLM)驱动的功能。它是一个有免费版和订阅选项的专有产品;不过,定价表并没有说明实际的订阅者权益以及它们与竞争产品的比较。基于我自己的理解,我会在讨论下面的功能时尽量澄清这一点,但这里先简单总结一下:

-   **Tab 自动补全**: 这是一组专有的微调模型,不仅在编辑器中提供代码补全,还能导航到下一个推荐的操作,所有这些都通过 Tab 键触发。仅对订阅用户开放。
-   **内联编辑（Inline Editing）**: 这是一个基于聊天的界面,使用 GPT 或 Claude 等基础模型,通过简单的差异视图对选定的代码进行编辑。对免费和付费用户都可用。
-   **聊天侧边栏（Chat Sidebar）**: 这也是一个基于聊天的界面,在侧边栏视图中进行更大的编辑,使用 GPT 或 Claude 等基础模型,允许更多空间进行更长的讨论、跨多个文件的代码示例建议等。对免费和付费用户都可用。
-   **Composer**: 这是另一个专门用于大型跨代码库重构的聊天界面,也使用 GPT 或 Claude 等基础模型,为多个文件生成差异,你可以逐页浏览和批准。对免费和付费用户都可用。

## Tab 自动补全

虽然其他基于 LLM 的编码工具都专注于聊天体验,但到目前为止,在我使用 Cursor 的过程中,Tab 自动补全最自然地融入了我的日常编码实践,并且节省了最多的时间。显然在这个功能上投入了大量的思考和技术研究,使它不仅能为一行、几行或整个函数提供补全建议,还能建议下一步编辑的位置。这意味着我可以做出部分更改,然后仅通过反复按 Tab 键就能自动完成整个文件中的相关更改。

使用这个功能的一种方式是作为超级代码重构工具。例如,假设我有一个代码块,其中的变量名使用了 `under_score` 表示法,我想把它转换成 `camelCase`。只需要重命名一个变量的一个实例,然后按 Tab 键浏览所有需要更新的行,包括其他相关变量。许多繁琐、容易出错的任务都可以通过这种方式自动化,而不需要编写脚本:

<video controls=""><source src="https://www.arguingwithalgorithms.com/videos/cursor-review/example1.webm" type="video/webm"><p>如果你的浏览器不支持 HTML 视频。这里是<a href="https://www.arguingwithalgorithms.com/videos/cursor-review/example1.webm" download="example1.webm">视频链接</a>供下载。</p></video>

有时 Tab 自动补全会独立发现 bug 并提出修复建议。很多时候,当我在 Python 或 Go 中添加依赖时,它会建议导入。如果我用引号包裹字符串,它会适当地转义内容。而且,和其他工具一样,它可以仅基于函数签名和可选的文档字符串来编写整个函数:

<video controls=""><source src="https://www.arguingwithalgorithms.com/videos/cursor-review/example2.webm" type="video/webm"><p>你的浏览器不支持 HTML 视频。这里是<a href="https://www.arguingwithalgorithms.com/videos/cursor-review/example2.webm" download="example2.webm">视频链接</a>供下载。</p></video>

总的来说,这个工具感觉像是在读我的心思,猜测我的下一步行动,让我能够少想代码,多想我正在构建的架构。

还值得注意的是:补全速度*非常快*,我从未感觉到等待建议的延迟。它们基本上在我停止打字的瞬间就出现了。如果等待时间太长,对我来说肯定是个致命缺陷。

那么,我对 Tab 自动补全有什么不满呢?一个是小烦恼:有时我来不及看到建议就继续打字,补全就消失了。一旦消失,似乎就没有办法让它重新出现,所以我必须输入其他内容并期待它再次出现。

我的另一个抱怨恰恰相反:有时补全完全错误,我故意忽略它。随后,虽然很少见,但我接受了一个完全不同的补全,而之前被拒绝的建议会悄悄地也被应用。这已经导致了一些难以追踪的 bug,因为我没有意识到错误的逻辑被接受了。我发现这些情况并不足够频繁到抵消 Tab 自动补全带来的生产力提升,但确实会影响它。

## 内联编辑、聊天侧边栏和 composer

据我所知,这些功能在与基础模型的交互方面都非常相似 - 我几乎只使用 Claude 3.5 Sonnet - 差异主要在用户界面上。

内联编辑可以通过选择一些代码并按 Ctrl-K/Cmd-K 来调用。我输入想要的更改,然后在文件中得到一个漂亮的差异视图,我可以接受或拒绝。我主要用它来实现函数内的代码片段或进行小的重构。

这个功能的一个很好的例子是,如果我有一个任务循环,我想把它们并行化:

<video controls=""><source src="https://www.arguingwithalgorithms.com/videos/cursor-review/example3.webm" type="video/webm"><p>如果你的浏览器不支持 HTML 视频。这里是<a href="https://www.arguingwithalgorithms.com/videos/cursor-review/example3.webm" download="example3.webm">视频链接</a>供下载。</p></video>

聊天侧边栏通过 Ctrl+L/Cmd+L 打开,为多轮对话提供更多空间,不过我对目前测试过的 LLM 模型有一个小抱怨,那就是它们*总是*先返回代码,而不是在有任何歧义时先寻求澄清。建议的代码有一个应用按钮,会在当前选择的文件中创建差异。这对于单个文件内的大型重构,或基于我打开的文件创建全新文件很有用。如果其他文件相关,可以手动添加到上下文中,但 Cursor 会根据查询和它在后台生成的索引尝试猜测哪些文件是相关的。

这里有一个例子,它接受应用程序的数据库 API 并创建一个 REST API 来访问它,包括参数验证和正确的 HTTP 状态码,*然后*编写一个客户端库来访问该 REST API:

<video controls=""><source src="https://www.arguingwithalgorithms.com/videos/cursor-review/example4.webm" type="video/webm"><p>如果你的浏览器不支持 HTML 视频。这里是<a href="https://www.arguingwithalgorithms.com/videos/cursor-review/example4.webm" download="example4.webm">视频链接</a>供下载。</p></video>

另一个例子,我正在使用聊天侧边栏将客户端库从 Python 转换为 Go。注意松散类型的 Python 是如何转换为定义良好的结构类型和惯用的 Go,包括错误处理!这根本不是 1:1 的重写:

<video controls=""><source src="https://www.arguingwithalgorithms.com/videos/cursor-review/example5.webm" type="video/webm"><p>如果你的浏览器不支持 HTML 视频。这里是<a href="https://www.arguingwithalgorithms.com/videos/cursor-review/example5.webm" download="example5.webm">视频链接</a>供下载。</p></video>

最后,Composer 专门用于跨文件重构。这也是我使用最少的功能,但它为一次一个地审查多个文件差异提供了更好的用户体验。

## .cursorrules 文件

直到我在(我认为过于简单的)文档中偶然发现这个功能,我才意识到它的存在,但各种聊天模式总是包含工作区根目录下的 `.cursorrules` 文件的内容来提供额外的上下文。我一直在尝试使用这个功能来告诉 LLM 仓库的编码标准、常用包和其他文档。

这个功能可能有助于解决我在 Cursor 中观察到的一个大障碍:除非这些编码风格和模式已经存在于你正在编辑的同一个文件中,否则它不会遵循这些风格和模式。例如,在 Khan Academy,我们使用一个专有库[2][7]在 Go 中的函数之间传递上下文。这用于日志记录、HTTP 请求等,所以 LLM 需要能够使用它。这在过去一直很困难,但也许一个写得好的 `.cursorrules` 是一个好的第一步。

目前的一个限制是每个工作区只能有一个这样的文件,所以像我们这样包含多种语言代码的单体仓库比一个只有一小组非常一致风格代码的小仓库更难设置。

另外文档表明 `.cursorrules` 文件只用于聊天模式,不用于 Tab 自动补全。不过我尝试过在工作区中将该文件固定在标签页中,并确认至少可以通过这种方式将其包含在 Tab 自动补全的上下文中。

## 我的工作流程的变化

像 Cursor 这样的工具最令人兴奋的不是我可以更快地写代码,因为说实话,实际写代码并不是瓶颈;事实上,我经常需要放慢速度,以避免过于关注代码而不是正在解决的高层次问题。真正的价值在于改变我编码的*方式*。

这项技术仍处于早期阶段,但以下是我发现的关于我的工作方式的变化,以及我期望在不久的将来看到的变化:

1. 我*更不*可能去寻找新的库或框架。不,我不会开始编写自己的加密库,但对于小型实用程序来说,让 LLM 根据我的特定需求编写它们比引入一个通用库更容易。这些库往往一开始很小巧轻便,然后,因为它们是开放的并被许多人使用,就会积累我不需要的功能和冗余代码。

    许多这样的库存在的唯一目的是减少样板代码,当权衡我编写和维护这些样板代码的时间时,这感觉是一个必要的权衡,但现在我可以让 LLM 为我做这件事,感觉不太值得付出这个代价。而且代价可能很大:你试过在写完一年或更长时间后运行一个 Node.js 项目吗?你可能还不如从头开始。

2. 我也不太担心在自己的代码中遵循 DRY(Don't Repeat Yourself,不要重复自己)原则。过早定义抽象可能会在以后产生大量技术债务,所以能够参考其他代码创建大量代码而不试图将其提取到函数或类中给了我更多的灵活性,而且我知道如果以后需要重构共享逻辑,LLM 也可以帮助我。

3. 我使用不太熟悉的语言或框架的意愿更高了。例如,我多年来一直在涉猎 R,特别是用于数据可视化。但是,坦白说,我很不擅长。我对 `dplyr` 没有深入的理解,而且似乎总有十几种不同的方法来完成同一个任务。现在我描述我想要的可视化,就能得到正确的数据操作和 `ggplot` 可视化。以前需要一个小时或更长时间的任务现在只需要五分钟,所以我不太可能放弃而改用 Python。

    也许有一天我甚至会用 Rust 写点东西。也许吧。

4. 我发现自己在将小组件集成到更大的代码库之前会快速迭代。这部分是为了解决 LLM 在处理更大代码库时的限制,但它也开启了我以前没有考虑过的有趣工作方式。如上例所示,我可以在像 Python 这样的动态类型语言中原型化一些逻辑,解决技术细节,然后立即将其转换为类型良好的 Go 来集成到 web 应用程序中。我可以让 LLM 自动生成测试数据,或者为我模拟一个后端来编写前端。当我还在验证一个想法时,为什么要承担在成熟代码库中工作的成本呢?

## 总结

我是否会在几年后继续使用 Cursor 还是转向另一个工具,我现在还说不准。我确信在写这篇文章时,Cursor 是 LLM 编码助手潜力的最佳范例,如果你想探索这类工具可能带来的价值,我建议你试一试。

[1]: https://www.cursor.com/

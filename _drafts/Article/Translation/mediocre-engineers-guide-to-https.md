---
title: 平庸工程师的HTTPS指南
date: 2024-05-28T04:38:43.572Z
authorURL: ""
originalURL: https://devonperoutky.super.site/blog-posts/mediocre-engineers-guide-to-https
translator: ""
reviewer: ""
---



- [HTTP请求的生命周期](#http请求的生命周期)
  - [1. 发送方发起请求](#1-发送方发起请求)
  - [2. DNS查询](#2-dns查询)
  - [3. TCP握手](#3-tcp握手)
  - [4. 传输HTTP请求](#4-传输http请求)
  - [5. 数据包通过互联网路由到服务器](#5-数据包通过互联网路由到服务器)
  - [文本如何穿越互联网的逐步解释](#文本如何穿越互联网的逐步解释)
  - [6. 服务器响应](#6-服务器响应)
  - [**7. 内容渲染**:](#7-内容渲染)
- [层级简要回顾](#层级简要回顾)
- [HTTPS = HTTP + 加密](#https--http--加密)
- [TLS握手](#tls握手)
  - [TLS握手](#tls握手-1)
- [**你在这里学到的一切都是谎言。**](#你在这里学到的一切都是谎言)
- [**TLS 1.3中的握手有什么不同？**](#tls-13中的握手有什么不同)
- [不要脸的广告](#不要脸的广告)

作为一名平庸的工程师，我一直把互联网和HTTPS通信视为理所当然，从未深入研究过。今天，我们将作为工程师进步，学习互联网通信工作原理的大致概述，特别关注HTTP和TLS。

互联网"只是"相互连接的计算机网络的网络。"互联网"一词字面意思是"网络之间"。它作为一个分组交换的[网状网络][6]运行，采用尽力而为的交付方式，这意味着对于数据包是否会被传递或需要多长时间没有任何保证。互联网之所以看起来运行如此顺畅（至少从技术角度看），是因为抽象层处理了重试、排序、去重、安全性和许多其他幕后工作。让我们开发人员只需专注于应用层（也就是在旧金山写HTTP请求，年薪30万美元）。

每一层提供特定功能，可以由不同的[协议][7]实现。这种模块化使得可以替换一层上的协议而不影响其他层上的协议。

这里是各层的简单表格。

我们稍后会更深入地讨论这些层，但首先，让我们看看它们的实际运作。

## HTTP请求的生命周期

以下是HTTP请求通过这些层的路径（为简洁起见跳过物理层）。

![图片2: 图片][2]

### 1. 发送方发起请求

这个过程从应用层开始，客户端（通常是网络浏览器）构建一个HTTP请求。HTTP是一种基于文本的协议，这意味着所有数据都以纯文本形式通过网络发送。

第一行通常包括：

* **HTTP方法**（GET、POST等）
* **请求的资源**（例如：`/index.html`）
* **协议版本**。

HTTP消息的其余部分包含`键: 值`格式的头部和一个可选的消息体。

**示例：HTTP请求**

```bash
GET /index.html HTTP/1.1
Host: www.example.com
Accept: text/html
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36
```

### 2. DNS查询

域名系统（DNS）将人类可读的域名（`**www.example.com**`）转换为IP地址（例如，`**93.184.216.34**`）。客户端查询DNS服务器以将域名解析为其对应的IP地址。这个过程通过多个解析器，直到到达权威服务器，后者完成域名到IP地址的转换。在非常高的层面上，三个组件是：

* **存根解析器**，位于客户端机器上，将请求路由到适当的递归解析器（下面解释）
* **递归解析器**，接收来自存根解析器的请求并查询权威服务器以解析域名 - 通常会缓存结果。您的互联网服务提供商（ISP）通常提供递归解析器，或者您可能使用公共解析器，如Google DNS（8.8.8.8）。
* **权威服务器**，包含域的实际DNS记录（如A、MX、CNAME等），并用这些记录中的信息响应查询。权威服务器是域名数据的最终真相来源。

当客户端使用域名请求资源时，计算机上的**存根解析器**向递归解析器发送查询以解析域名。

递归解析器根据需要查询权威DNS服务器，将域名解析为IP地址。

### 3. TCP握手

现在我们有了服务器的IP地址，客户端可以开始传输HTTP，我们进入传输层。传输层有两个主要协议，**TCP（传输控制协议）和UDP（用户数据报协议）**。

💡

TCP是一种面向连接的协议，确保应用程序之间可靠、有序和经过错误检查的数据传输。

UDP是一种无连接协议，提供快速、低开销的数据传输，但不保证传输、顺序或错误检查。

截至2024年，TCP是互联网上管理数据传输的主要协议，而UDP使用较少，通常用于实时应用，如流媒体或视频通话，其中低延迟至关重要，偶尔的数据包丢失是可接受的。现在回到主题。

一旦客户端获得IP地址，它就会在端口80（HTTP的标准端口）上与服务器建立TCP连接。这涉及三步握手：

* **SYN**：客户端向服务器发送SYN（同步）数据包请求连接。
* **SYN-ACK**：服务器以SYN-ACK（同步-确认）数据包响应，确认请求。
* **ACK**：客户端向服务器发回ACK（确认）数据包，建立可靠连接。

### 4. 传输HTTP请求

建立TCP连接后，客户端发送实际的HTTP请求。如前所述，HTTP是基于文本的协议，因此请求头和正文（如果有）以纯文本形式发送。

### 5. 数据包通过互联网路由到服务器

**⚠️⚠️⚠️⚠️⚠️ 我们要深入了 ⚠️⚠️⚠️⚠️⚠️**

当客户端发送请求时，数据包不会直接传输到服务器。相反，它们通过各种网络设备（主要是路由器）遵循路径，这些设备确定数据包到达服务器网络网关的最佳路线。从那里，链路层开始发挥作用。

### 文本如何穿越互联网的逐步解释

1. **初始传输**：
客户端设备将HTTP请求数据封装到TCP段中，然后封装到IP数据包中。这些数据包进一步封装成更小的块，称为帧，适合链路层（例如，如果使用有线连接，则为以太网帧）。

3. **本地网络**：
帧通过本地网络传输到客户端的路由器。链路层处理这个本地网络内的通信，确保帧到达路由器。

5. **本地路由器处理**：
路由器接收帧，剥离链路层头部，并处理IP数据包。路由器检查数据包中的目标IP地址，并确定通往服务器的路径上的下一跳。

7. **跨网络路由**：
路由器将数据包转发到下一个网络，通常通过一个或多个中间路由器。每个中间路由器重复这个过程：接收数据包，确定下一跳，并转发它们。

9. **最终网络**
最终，数据包到达与目标服务器相同网络上的路由器。这个路由器执行最终的路由决策，并将数据包发送到适当的本地设备（服务器）。

11. **服务器接收**：
服务器的路由器通过本地网络段将数据包转发到服务器。链路层确保帧正确传输到服务器的网络接口。（它一直在为整个过程中的每台机器→机器通信做这件事。）

13. **服务器处理**：
服务器接收帧，提取IP数据包，并处理封装的TCP段以重建原始HTTP请求。然后服务器生成HTTP响应，过程反转，将响应发送回客户端。

⁉️

通过互联网发送数据包的过程（网络层）基本上用于互联网上的所有通信。因此它用于之前的所有步骤（如解析域名、TCP握手等），但一次只能解释这么多。

### 6. 服务器响应

服务器接收HTTP请求并处理它。处理请求后，服务器向客户端发送HTTP响应。响应包括：

* **协议**（使用的HTTP版本）
* **状态信息**（HTML状态码，如200、404等）
* **响应头**（与请求头类似，但是响应）
* **请求的内容/正文**（实际内容，如请求页面的HTML或JSON数据）

```bash 
HTTP/1.1 200 OK
Date: Sat, 26 May 2023 10:00:00 GMT
Server: Apache/2.4.41 (Ubuntu)
Content-Type: text/html
Content-Length: 3456

<!DOCTYPE html>
<html>
<head>
    <title>Example Page</title>
</head>
<body>
    <h1>Hello, world!</h1>
</body>
</html>
```

调试请求时，你可能见过类似这样的内容。

![图片3: 图片][3]

### **7. 内容渲染**:

客户端接收HTTP响应并处理它。浏览器解释HTML并在屏幕上渲染内容。如果响应包括额外资源（例如，图片、CSS、JavaScript），浏览器将发出进一步的HTTP请求来获取这些资源，遵循相同的过程。

现在我们已经完成了基本的HTTP请求，但有一个问题。**它根本不安全。**任何监听连接的人都可以查看100%的来回传递的数据。此外，有人可能假装是服务器，使客户端被欺骗发送有价值的信息。这就是**安全层**发挥作用的地方。

## 层级简要回顾

在这里，让我们简要回顾一下各层及其目的，同时介绍安全层。

* **应用层**：应用程序创建和通信用户数据的地方。这是你交互最多的层。使用传输层服务进行可靠或不可靠的数据传输。协议包括HTTP、FTP、SSH、SMTP。使用端口来寻址进程/服务。
* **安全层**：通过提供加密、认证和数据完整性确保安全通信。常见协议包括TLS（传输层安全）及其前身SSL（安全套接字层）。这一层保护传输中的数据并验证通信方的身份。
* **传输层**：管理主机到主机的通信，为应用数据提供通道。包括：

* **UDP**：不可靠、无连接的数据报服务。
* **TCP**：可靠、面向连接的服务，具有流量控制和连接建立。

* **网络层**：负责通过路由将数据包跨网络边界交换，通过各种中间路由器。主要协议：互联网协议（IP）。
* **链路层**：管理没有路由器的本地网络通信。定义本地网络拓扑和将数据报传输到相邻主机的接口。

特别注意**安全层**，因为该层是HTTP请求（我们刚刚介绍的）和HTTPS请求（[当前互联网的~86%][8]并且还在增长）之间的决定性区别。

## HTTPS = HTTP + 加密

**HTTPS是带有加密和验证的HTTP**。虽然有多种方式可以在互联网上保护HTTP通信，但目前大家使用的实现是传输层安全（TLS）**。**

TLS是客户端和服务器如何验证彼此身份并确保所有负载以双方都能解密的方式加密。具体来说，**TLS握手过程**决定了客户端和服务器将如何交换加密和验证密钥。一旦密钥交换完成，客户端和服务器将像正常一样使用HTTP通信，并使用密钥加密和验证消息。

HTTPS的流程与我们之前介绍的HTTP请求完全相同，只是在应用层和传输层之间添加了安全层（尽管通常TCP用于TLS握手）。

![图片4: 图片][4]

## TLS握手

TLS握手是为了让客户端和服务器就通信的几个不同方面达成一致。具体来说，用于验证、压缩和加密消息的算法集合。

🔒

这些算法集合被称为**密码套件**。准确地说，除了压缩算法外，所有算法都被视为密码套件，但为简洁起见，我将在接下来把完整的集合称为密码套件。

通过就所有这些算法达成一致，交换随机种子，以及包含私钥的服务器SSL证书；客户端和服务器可以生成一个对称密钥，用于加密和验证来回传递的消息。这个就密码套件达成一致并分发必要信息（种子和SSL证书）的过程被称为TLS握手。

![图片5: s][5]

来源：Cloudflare

**注意：**所有通信都通过TCP进行，蓝色步骤表示TCP握手，黄色步骤是TLS握手。

### TLS握手

1. **客户端问候**

1. 客户端将发送"客户端问候"，这是一个TCP消息，向服务器指定它支持的**密码套件**，以及支持的TLS版本和一个随机数（称为客户端随机数）

3. **服务器问候**

1. 服务器将以"服务器问候"响应，这是一个TCP消息，包含所选的TLS版本、所选的密码套件算法和它自己的随机数（服务器随机数）

5. **证书验证**

1. 客户端通过证书颁发机构验证服务器的SSL证书，并检索服务器的公钥。

7. **预主密钥生成**

1. 客户端生成预主密钥，用服务器的公钥加密，并发送给服务器。

9. **解密**

1. 服务器使用其私钥解密预主密钥。

11. **会话密钥创建**

1. 客户端和服务器都使用客户端随机数、服务器随机数和预主密钥创建会话密钥。

13. **客户端就绪**

1. 客户端发送用会话密钥加密的"完成"消息。

15. **服务器就绪**

1. 服务器发送用会话密钥加密的"完成"消息。

17. **安全HTTP通信**

1. 会话密钥用于安全对称加密，确保双方现在可以安全通信。

好了。这就是TLS握手，除了还有一件事，那就是...

**你在这里学到的一切都是谎言。**
--------------------------------------------

我们刚刚描述的过程是针对TLS的原始版本，与更现代的TLS 1.3版本相比已经过时。

**TLS 1.3中的握手有什么不同？**
---------------------------------------------------

我们刚刚经历的过程有点过时，但由于它介绍了安全服务器<\>客户端通信所需达成一致的必要概念，所以是一个很好的起点。

当前版本的TLS（\>1.3）出于安全原因不支持RSA（和各种其他密码套件）。较新的版本更加固执己见，允许的选项明显减少，这使它们更简单、更安全、更快。然而，组件和概念都非常相似。你仍然有一个TLS握手过程，就压缩方法、服务器认证和密钥交换达成一致，目的是生成对称加密密钥，用于保护通过TCP交换的数据包的数据安全。

TLS 1.3不支持RSA，也不支持其他容易受到攻击的密码套件和参数。它还缩短了TLS握手，使TLS 1.3握手既更快又更安全。

TLS 1.3握手的基本步骤是：

* **客户端问候：** 客户端发送客户端问候消息，包含协议版本、客户端随机数和密码套件列表。由于TLS 1.3已移除对不安全密码套件的支持，可能的密码套件数量大大减少。客户端问候还包括将用于计算预主密钥的参数。本质上，客户端假设它知道服务器首选的密钥交换方法（由于简化的密码套件列表，它可能确实知道）。这减少了握手的总体长度——这是TLS 1.3握手与TLS 1.0、1.1和1.2握手之间的重要区别之一。
* **服务器生成主密钥：** 此时，服务器已收到客户端随机数和客户端的参数及密码套件。它已经有了服务器随机数，因为它可以自己生成。因此，服务器可以创建主密钥。
* **服务器问候和"完成"：** 服务器问候包括服务器的证书、数字签名、服务器随机数和所选的密码套件。因为它已经有了主密钥，所以它还发送"完成"消息。
* **最终步骤和客户端"完成"：** 客户端验证签名和证书，生成主密钥，并发送"完成"消息。
* **实现安全对称加密**

就是这样。现在去参加你的技术面试吧。

## 不要脸的广告

如果你想阅读更多像这样的文章，你可以订阅。

除了写平庸的[技术博客文章][9]，我还提供咨询服务并运营一家[开发机构][10]。我[构建了很多东西][9]，包括

...一个用于企业知识库的RAG AI聊天机器人和搜索工具 - 被Brex收购

...在Twilio和Valon的分布式Python和Scala服务

...获奖的 Military Recall App 被 SAIC 选中用于美国国防部

我还帮助领导了一些精英创业公司的团队。如果你正在寻找软件开发服务或项目咨询，我可能能够帮助。请随时通过[devonperoutky@gmail.com][11]联系我。

[1]: https://files.oaiusercontent.com/file-SyCerofEEDgemcHfPpquHWxP?se=2024-05-26T17%3A15%3A21Z&sp=r&sv=2023-11-03&sr=b&rscc=max-age%3D31536000%2C%20immutable&rscd=attachment%3B%20filename%3D53c7983c-c33e-4b28-80ff-ad5cdd387868.webp&sig=MN94zDnTPF%2BB0jZFNe434yjt40e6dIcfT%2BQiedrSLBg%3D
[2]: https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/a391823a-fee1-403b-b844-bb42d82d2238/HTTP_Request/w=3840,quality=90,fit=scale-down
[3]: https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/c06f5733-3c3b-4311-83f6-fad123fa5c4e/Screenshot_2024-05-26_at_12.22.31_AM/w=3840,quality=90,fit=scale-down
[4]: https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/1bf738a0-d2ec-40ab-9b7c-6b595c3568bf/HTTPS_Request/w=3840,quality=90,fit=scale-down
[5]: https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/90ee7477-92fc-45c0-95e1-4bebe176aee7/Untitled/w=3840,quality=90,fit=scale-down
[6]: https://en.wikipedia.org/wiki/Mesh_networking
[7]: https://en.wikipedia.org/wiki/Communication_protocol
[8]: https://devonperoutky.super.site/blog-posts/intro-to-llms-for-engineers-1
[9]: https://devonperoutky.super.site/
[10]: http://jedsoftware.com/
[11]: mailto:devonperoutky@gmail.com
